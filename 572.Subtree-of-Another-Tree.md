## 572. Subtree of Another Tree | Easy | Recursion + same tree | 
#### 1. 基本思路
###### 1.1 Recursion + same tree

​	判断一棵树(设为A树)是否为另一棵树(设为B树)的子树(设为B-树)，需要对比A树与以每个B树节点为根节点的B-树是否相同，可以使用深度优先搜索的方法递归判断。而判断两棵树是否相等也可以使用深度优先搜索的方法，递归判断每个相同位置的节点是否相同。

Time Complexity: O(n x m) - n：B树节点个数 m：A树节点个数

* 需要递归遍历B树每个节点，每个节点都需要判断A树和B-树是否相等

Space Complexity: O(n)

* 虽然是两个递归嵌套，但是只有当对比的两个根节点值相等的时候，才会进入判断子树相等的递归。
* 如果某棵B-树的根节点与A树根节点相同，进入判断两数相等的递归：
    * 如果A树的节点个数大于等于B-树的节点个数，此时递归会在B树的叶子节(同样也是B-树的叶子节点)点返回，那么此时的最大递归层数就是O(n)
    * 如果A树的节点个数小于B-树的节点个数，此时递归会在A树的叶子节点返回，那么此时最大递归层数也没有超过O(n)

#### 1.2 Preorder + KMP

#### 2. 代码
###### 2.1 Recursion + same tree

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSubtree(TreeNode root, TreeNode subRoot) {
        if (root == null) {
            return subRoot == null;
        }

        return isSameTree(root, subRoot) || isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);
    
    }

    private boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) {
            return true;
        }
        if (p == null || q == null || p.val != q.val) {
            return false;
        }

        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }
}
```

